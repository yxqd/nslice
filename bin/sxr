#!/usr/bin/env python
# Jiao Lin <linjiao@caltech.edu>

"""Helper for MCViNE simulation of resolution function

To perform a MCViNE simulation of resolution function,
we need 
* a sampleassembly.xml with correct orientation of the crystal
* a scatterer.xml with correct delta function kernel

This script helps perform calculations that
are useful for constructing the sampleassembly folder
with these files.

Inputs:
  i.xtal_ori
  i.hklE

Commands:
* kernelQ: compute Q vector for the kernel xml
* alignment: compute alignment angles for the sampleassembly xmls
* psi: compute the psi angle to be used in simulation (rotation of the whole sample assembly)

Usage:
  sxr -h | --help
  sxr kernelQ
  sxr alignment
  sxr psi  --Ei=<Ei> [--angles=<angleaxis>]
"""

def main():
    import docopt
    args = docopt.docopt(__doc__)
    # print args
    if args['kernelQ']:
        kernelQ()
    elif args['alignment']:
        alignment()
    elif args['psi']:
        psi(args['--Ei'], args['--angles'])
    return


def load_hklE():
    from nslice.io import load_mod
    m = load_mod("i.hklE")
    hkl = nslice.hkl(*m['hkl'])
    E = m['E']
    return hkl, E


def kernelQ():
    hkl, E = load_hklE()
    from nslice.io import load_xtal_ori
    xo = load_xtal_ori("i.xtal_ori")
    t = np.array([xo.ra, xo.rb, xo.rc])
    Qx, Qy, Qz = np.dot(hkl, t)
    # convert to MC convention
    Q = Qy, Qz, Qx
    print Q
    return


def alignment():
    # load xtal ori
    from nslice.io import load_xtal_ori
    xo = load_xtal_ori("i.xtal_ori")
    
    # compute u, v, w in the cartesian coordinate system attached
    # to the crystal
    
    # ra, rb, rc are defined in a cartesian
    # coordinate system attached to the crystal (CCSC)
    r = np.array([xo.ra, xo.rb, xo.rc])
    # compute u, v in cartesian coordinate system
    u_cart = np.dot(xo.u, r)
    v_cart = np.dot(xo.v, r)
    # normalize them
    lu = np.linalg.norm(u_cart); u_cart/=lu
    lv = np.linalg.norm(v_cart); v_cart/=lv
    # u and v is not necesarily perpendicular to each other
    # let us compute w 
    w = np.cross(u_cart, v_cart); w/=np.linalg.norm(w)
    # now we can compute vprime, a unit vector perpedicular to
    # u_cart and ez
    vprime_cart = np.cross(w, u_cart)
    
    # now we have u_cart, vprime_cart, and w.
    # they are normal to each other. we now need to map
    # them into x,y,z
    m = np.vstack((u_cart, vprime_cart, w))
    # use sampleassembly.geometer.rotateVector.toAngles(m)
    # can convert it into alighment angles
    from nslice.mc.rotateVector import toAngles
    angles = toAngles(m)
    print angles
    return


def psi(Ei, angleaxis):
    # load xtal ori
    from nslice.io import load_xtal_ori
    xo = load_xtal_ori("i.xtal_ori")
    hkl, Etarget = load_hklE()
    #
    Ei = float(Ei)
    # 
    if not angleaxis:
        angleaxis = 0, 360, 0.5
    else:
        angleaxis = eval(angleaxis)
        pass
    angles = np.arange(*angleaxis)
    #
    from nslice.xtalori import Eresidual
    psi, eres = Eresidual(xo, hkl, Etarget, angles, Ei).T
    good = np.abs(eres) < Ei/10.
    print np.vstack((psi[good], eres[good])).T
    return


import nslice, numpy as np

if __name__ == '__main__': main()
